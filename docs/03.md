## Tutorial

Arpeggeo is commonly used to build web services.

Here we will show you how to build simple web services with Jetty that use
Arpeggeo.

### Hello World

This is the most basic web service--in fact, it doesn't directly use Arpeggeo
at all. However, it contains all the imports and objects that the other
examples will need, as well as providing an example of writing a Jetty web
service in Scala.

This service can be accessed at `http://localhost:8000/greeting` and should
print "hello world". You may want to substitude your own values for `myapp` and
`endpoint`.

```scala
package trellis.rest.myapp

import javax.servlet.http.HttpServletRequest
import javax.ws.rs.{GET, Path, DefaultValue, PathParam, QueryParam}
import javax.ws.rs.core.{Response, Context}

import trellis._
import trellis.operation._
import trellis.process._

object MyApp {
  val server = Server("myapp", "src/main/resources/myapp-catalog.json")
  def response(mime:String)(data:Any) = Response.ok(data).`type`(mime).build()
}

@Path("/greeting")
class HelloWorld {
  @GET
  def get(@Context req:HttpServletRequest) = {
    // give a friendly greeting
    MyApp.response("text/plain")("hello world")
  }
}
```

### Adder

With that out of the way, here's a REST service that actually does something:
it treats the final part of the URL as a number, adds one to it, and returns
that number as plaintext. For instance, `http://localhost:8080/adder/127` would
return "128".

The important thing to see here is that `ParseInt` doesn't actually do any
work. It creates an operation which when run will parse an input `String` and
return an `Int`. But running operations isn't the only thing you can do. In our
case, `opX + 1` actually builds us a new operation, which evaluates `opX` and
then adds one to it. If there is an exception (i.e. the parameter is not a
valid number) it will only occur when `MyApp.server.run` is called.

This means that instead of sprinkling error-handling code through your handler,
you only need to guard your calls to `server.run`. Combining operations allows
the web service author to focus on correctly encoding application logic without
having to handle errors at every possible point.

Calling `server.run` returns an integer value which can be passed to the user.

```scala
@Path("/adder/")
class AddOne {
  @GET
  @Path("/{x}")
  def get(@PathParam("x") s:String,
          @Context req:HttpServletRequest) = {
    // parse the given integer
    val opX:Op[Int] = ParseInt(s)

    // add one
    val opY:Op[Int] = opX + 1

    // run the operation
    val data:String = try {
      val y:Int = MyApp.server.run(opY)
      y.toString
    } catch {
      case e => e.toString
    }

    MyApp.response("text/plain")(data)
  }
}
```

### Bounding Box Union

This example is similar to the previous one, but a bit more complicated: it
uses `trellis.Extent`, an object which represents a geographical bounding box.
The service uses two extents, each encoded in a string as
`xmin,ymin,xmax,ymax`. For example, using the Web Mercator coordinate system a
bounding box around Philadelphia might be encoded as:

`-8475497.88486,4825540.69147,-8317922.88486,4954765.69147`

This service takes two such extents and combines them, returning the smallest
extent that contains both of them. For instance, the request:

`http://localhost:8000/bbox/0,0,10,10/union/5,-10,15,0`

will result in `0,-10,15,10`.

```scala
@Path("/bbox/")
class BoundingBox {
  @GET
  @Path("/{extent1}/union/{extent2}")
  def get(@PathParam("extent1") s1:String,
          @PathParam("extent2") s2:String,
          @Context req:HttpServletRequest) = {
    // parse the given extents
    val e1:Op[Extent] = ParseExtent(s1)
    val e2:Op[Extent] = ParseExtent(s2)

    // combine the extents
    val op:Op[Extent] = CombineExtents(e1, e2)

    // run the operation
    val data = try {
      val extent:Extent = MyApp.server.run(op)
      extent.toString
    } catch {
      case e => e.toString
    }

    MyApp.response("text/plain")(data)
  }
}
```

### Draw Raster

```scala
@Path("/draw/")
class DrawRaster {
  @GET
  @Path("/{name}/palette/{palette}/shades/{shades}")
  def get(@PathParam("name") name:String,
          @PathParam("palette") palette:String,
          @PathParam("shades") shades:String,
          @Context req:HttpServletRequest) = {

    // load the raster
    val rasterOp = LoadRaster(name)

    // find the colors to use
    val paletteOp = ForEach(SplitOnComma(palette))(ParseHexInt(_))
    val numOp = ParseInt(shades)
    val colorsOp = ColorsFromPalette(paletteOp, numOp)

    // find the appropriate quantile class breaks to use
    val histogramOp = BuildMapHistogram(rasterOp)
    val breaksOp = FindColorBreaks(histogramOp, colorsOp)

    // render the png
    val pngOp = RenderPNG(rasterOp, breaksOp, 0, true)

    // run the operation
    try {
      val img:Array[Byte] = MyApp.server.run(pngOp)
      MyApp.response("image/png")(img)
    } catch {
      case e => MyApp.response("text/plain")(e.toString)
    }
  }
}
```

### Conclusion
